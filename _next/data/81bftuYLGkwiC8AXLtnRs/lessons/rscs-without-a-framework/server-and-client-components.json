{"pageProps":{"post":{"attributes":{"description":"Learn how to build a simple React app with server and client components using React Server Components as taught by Brian Holt in Intermediate React v6 for Frontend Masters. Discover the differences between client and server components, and how to implement async functions in server components for efficient rendering.","keywords":["React","Server Components","Brian Holt","Frontend Masters","JavaScript"]},"html":"<p>Let&#39;s put together the most simple React app so that we can render it using our newly-created framework.</p>\n<p>Let&#39;s make a directory, <code>src</code> and put a file in there a file called App.jsx</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Suspense</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ServerComponent</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ServerComponent&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ClientComponent</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./ClientComponent&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rendering App server component&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&lt;<span class=\"hljs-attr\">h1</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>}&gt;\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Notes App<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ServerComponent</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ClientComponent</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span></span>\n  );\n}\n</code></pre><p>We&#39;re going to putting a lot of console logs in here just so you can see where things are happening and in what order. Great, so we&#39;ll have two components: a client and a server component to show you the difference. The client component won&#39;t render at all on the server and will be included in the bundle. Likewise the server component will only be rendered in the server and won&#39;t be included in the bundle.</p>\n<p>So where does the App component render? On the server. By default <em>everything</em> renders on the server. By default you can&#39;t use any hooks that have interactivity like useState; you have to declare it a client component to do that.</p>\n<p>Okay, so let&#39;s make our client component. Make ClientComponent.jsx and put in there</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-string\">&quot;use client&quot;</span>;\n\n<span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ClientComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rendering ClientComponent client component&quot;</span>);\n  <span class=\"hljs-keyword\">const</span> [counter, setCounter] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">legend</span>&gt;</span>Client Component<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">legend</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Counter: {counter}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> setCounter(counter + 1)}&gt;Increment<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span></span>\n  );\n}\n</code></pre><p>Nothing you haven&#39;t seen before except the weird <code>&quot;use client&quot;;</code> at the top. This is how you declare a component is to be rendered on the client and not on the server. After that it&#39;s just React as you know and love it. One note: <code>&quot;use server;&quot;</code> is not necessary, it&#39;s assumed.</p>\n<p>Okay, let&#39;s make <code>ServerComponent.jsx</code></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AsyncDatabase</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;promised-sqlite3&quot;</span>;\n<span class=\"hljs-keyword\">import</span> path <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;node:path&quot;</span>;\n\n<span class=\"hljs-comment\">// this page assumes that you are logged in as user 1</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyNotes</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rendering MyNotes server component&quot;</span>);\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchNotes</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;running server function fetchNotes&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> dbPath = path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;../../notes.db&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">AsyncDatabase</span>.<span class=\"hljs-title function_\">open</span>(dbPath);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">from</span> = <span class=\"hljs-keyword\">await</span> db.<span class=\"hljs-title function_\">all</span>(\n      <span class=\"hljs-string\">&quot;SELECT n.id as id, n.note as note, f.name as from_user, t.name as to_user FROM notes n JOIN users f ON f.id = n.from_user JOIN users t ON t.id = n.to_user WHERE from_user = ?&quot;</span>,\n      [<span class=\"hljs-string\">&quot;1&quot;</span>]\n    );\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-keyword\">from</span>,\n    };\n  }\n\n  <span class=\"hljs-keyword\">const</span> notes = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchNotes</span>();\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">legend</span>&gt;</span>Server Component<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">legend</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">thead</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>From<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>To<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>Note<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">thead</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tbody</span>&gt;</span>\n            {notes.from.map(({ id, note, from_user, to_user }) =&gt; (\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{id}</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>{from_user}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>{to_user}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>{note}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n            ))}\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tbody</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span></span>\n  );\n}\n</code></pre><ul>\n<li>We&#39;re doing SQL in React!? Well, yes, but also no. This all happening server-side before it&#39;s being sent down to the browser. So it&#39;s basically the same as doing an API request but it&#39;s doing the full React lifecycle here on the server. That&#39;s one of the nicest aspects of RSC - you get to write all of this as if it was being done server side but instead of having a server portion and a client portion, it&#39;s all the same file!</li>\n<li>Notice that it&#39;s an <code>async</code> function - this is a fun ability that only server components have. Since it&#39;s all rendering once and on the server, you can do async functions for react server components.</li>\n</ul>\n<p>This is deliberately a pared-down feature set as we&#39;re going to only do the bare minimum to implement a by-hand RSC-server implementation. Once we get into Next.js I&#39;ll show you more advance React server component features.</p>\n<p>Okay, one more file, call it Client.jsx and put this in there.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { createRoot } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/client&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { createFromFetch } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-server-dom-webpack/client&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;doodle.css/doodle.css&quot;</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;fetching flight response&quot;</span>);\n<span class=\"hljs-keyword\">const</span> fetchPromise = <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/react-flight&quot;</span>);\n<span class=\"hljs-keyword\">const</span> root = <span class=\"hljs-title function_\">createRoot</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>));\n<span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-title function_\">createFromFetch</span>(fetchPromise);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;rendering root&quot;</span>, p);\nroot.<span class=\"hljs-title function_\">render</span>(p);\n</code></pre><p><code>createFromFetch</code> allows us to turn a fetch request to an API endpoint into a React component directly. This is the magic of React server components and probably one you&#39;ll never write by hand again - your framework will always do this for you. But I wanted to demystify what it&#39;s doing for you. You make a request to an API endpoint, get a promise, and hand it to React to render. That&#39;s it!</p>\n","markdown":"\nLet's put together the most simple React app so that we can render it using our newly-created framework.\n\nLet's make a directory, `src` and put a file in there a file called App.jsx\n\n```javascript\nimport { Suspense } from \"react\";\nimport ServerComponent from \"./ServerComponent\";\nimport ClientComponent from \"./ClientComponent\";\n\nexport default function App() {\n  console.log(\"rendering App server component\");\n  return (\n    <Suspense fallback={<h1>Loading...</h1>}>\n      <h1>Notes App</h1>\n      <ServerComponent />\n      <ClientComponent />\n    </Suspense>\n  );\n}\n```\n\nWe're going to putting a lot of console logs in here just so you can see where things are happening and in what order. Great, so we'll have two components: a client and a server component to show you the difference. The client component won't render at all on the server and will be included in the bundle. Likewise the server component will only be rendered in the server and won't be included in the bundle.\n\nSo where does the App component render? On the server. By default _everything_ renders on the server. By default you can't use any hooks that have interactivity like useState; you have to declare it a client component to do that.\n\nOkay, so let's make our client component. Make ClientComponent.jsx and put in there\n\n```javascript\n\"use client\";\n\nimport { useState } from \"react\";\n\nexport default function ClientComponent() {\n  console.log(\"rendering ClientComponent client component\");\n  const [counter, setCounter] = useState(0);\n\n  return (\n    <fieldset>\n      <legend>Client Component</legend>\n      <p>Counter: {counter}</p>\n      <button onClick={() => setCounter(counter + 1)}>Increment</button>\n    </fieldset>\n  );\n}\n```\n\nNothing you haven't seen before except the weird `\"use client\";` at the top. This is how you declare a component is to be rendered on the client and not on the server. After that it's just React as you know and love it. One note: `\"use server;\"` is not necessary, it's assumed.\n\nOkay, let's make `ServerComponent.jsx`\n\n```javascript\nimport { AsyncDatabase } from \"promised-sqlite3\";\nimport path from \"node:path\";\n\n// this page assumes that you are logged in as user 1\nexport default async function MyNotes() {\n  console.log(\"rendering MyNotes server component\");\n  async function fetchNotes() {\n    console.log(\"running server function fetchNotes\");\n    const dbPath = path.resolve(__dirname, \"../../notes.db\");\n    const db = await AsyncDatabase.open(dbPath);\n    const from = await db.all(\n      \"SELECT n.id as id, n.note as note, f.name as from_user, t.name as to_user FROM notes n JOIN users f ON f.id = n.from_user JOIN users t ON t.id = n.to_user WHERE from_user = ?\",\n      [\"1\"]\n    );\n    return {\n      from,\n    };\n  }\n\n  const notes = await fetchNotes();\n\n  return (\n    <fieldset>\n      <legend>Server Component</legend>\n      <div>\n        <table>\n          <thead>\n            <tr>\n              <th>From</th>\n              <th>To</th>\n              <th>Note</th>\n            </tr>\n          </thead>\n          <tbody>\n            {notes.from.map(({ id, note, from_user, to_user }) => (\n              <tr key={id}>\n                <td>{from_user}</td>\n                <td>{to_user}</td>\n                <td>{note}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    </fieldset>\n  );\n}\n```\n\n- We're doing SQL in React!? Well, yes, but also no. This all happening server-side before it's being sent down to the browser. So it's basically the same as doing an API request but it's doing the full React lifecycle here on the server. That's one of the nicest aspects of RSC - you get to write all of this as if it was being done server side but instead of having a server portion and a client portion, it's all the same file!\n- Notice that it's an `async` function - this is a fun ability that only server components have. Since it's all rendering once and on the server, you can do async functions for react server components.\n\nThis is deliberately a pared-down feature set as we're going to only do the bare minimum to implement a by-hand RSC-server implementation. Once we get into Next.js I'll show you more advance React server component features.\n\nOkay, one more file, call it Client.jsx and put this in there.\n\n```javascript\nimport { createRoot } from \"react-dom/client\";\nimport { createFromFetch } from \"react-server-dom-webpack/client\";\nimport \"doodle.css/doodle.css\";\n\nconsole.log(\"fetching flight response\");\nconst fetchPromise = fetch(\"/react-flight\");\nconst root = createRoot(document.getElementById(\"root\"));\nconst p = createFromFetch(fetchPromise);\nconsole.log(\"rendering root\", p);\nroot.render(p);\n```\n\n`createFromFetch` allows us to turn a fetch request to an API endpoint into a React component directly. This is the magic of React server components and probably one you'll never write by hand again - your framework will always do this for you. But I wanted to demystify what it's doing for you. You make a request to an API endpoint, get a promise, and hand it to React to render. That's it!\n","slug":"server-and-client-components","title":"Server and Client Components","section":"RSCs without a Framework","icon":"file-code","filePath":"/home/runner/work/intermediate-react-v6/intermediate-react-v6/lessons/03-rscs-without-a-framework/C-server-and-client-components.md","nextSlug":"/lessons/rscs-without-a-framework/the-rsc-server","prevSlug":"/lessons/rscs-without-a-framework/rsc-dependencies"}},"__N_SSG":true}