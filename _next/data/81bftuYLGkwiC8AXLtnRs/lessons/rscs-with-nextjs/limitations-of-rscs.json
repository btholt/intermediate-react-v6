{"pageProps":{"post":{"attributes":{"title":"Limitations of RSCs","description":"In the Intermediate React v6 course by Brian Holt for Frontend Masters, learn how to work with React Server Components (RSC) by implementing a client component that renders a server component, with special emphasis on overcoming data transmission barriers between them using pre-rendering and client-side APIs. Discover key insights on optimizing React applications with this advanced web development tutorial.","keywords":["React","Server Components","Client Components","Web Development","Brian Holt"]},"html":"<p>Okay, so we saw using a server component as a parent and passing data to a client component. What about going the other way? A client component rendering a server component? Well, it works, sort of, with a some caveats. A good thing to keep in mind is that, by necessity, server components render first and client components second. So we can&#39;t cross that barrier back the other way - going from the second/client components to the first/server components. But there&#39;s a little trick that we can do to somewhat get around this.</p>\n<p>Make a folder in app, call it <code>who-am-i</code>. Put a page.js file in there.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ClientPage</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./clientPage&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">WhoAmI</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./whoAmI&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">WhoAmIPage</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ClientPage</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{1}</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WhoAmI</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ClientPage</span>&gt;</span></span>\n  );\n}\n</code></pre><p>This is the secret trick: we can just pre-render the server component first, and then pass the result to a client component to render it. Pretty cool, right? We&#39;ll talk more about it in a sec, but let&#39;s write whoAmI.js first.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AsyncDatabase</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;promised-sqlite3&quot;</span>;\n\n<span class=\"hljs-comment\">// this page assumes that you are logged in as user 1</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getWhoAmI</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">AsyncDatabase</span>.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&quot;./notes.db&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> db.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>, [<span class=\"hljs-string\">&quot;1&quot;</span>]);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">WhoAmI</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getWhoAmI</span>();\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Who Am I?<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n        You are {user.name} and your id is {user.id}\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre><p>And now clientPage.js</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-string\">&quot;use client&quot;</span>;\n<span class=\"hljs-keyword\">import</span> updateUsername <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./updateUsername&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ClientWhoAmIPage</span>(<span class=\"hljs-params\">{ children, id }</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      {children}\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">{updateUsername}</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>Enter new username<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;username&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;username&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;hidden&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;id&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{id}</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre><p>Now we have a client page rendering a server page! Let&#39;s go write that form action, updateUsername</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-string\">&quot;use server&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AsyncDatabase</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;promised-sqlite3&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { redirect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;next/navigation&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateUsername</span>(<span class=\"hljs-params\">formData</span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;updateUsername called&quot;</span>, formData);\n\n  <span class=\"hljs-keyword\">const</span> username = formData.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;username&quot;</span>);\n  <span class=\"hljs-keyword\">const</span> id = formData.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;id&quot;</span>);\n\n  <span class=\"hljs-keyword\">if</span> (!username || !id) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;All fields are required&quot;</span>);\n  }\n\n  <span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">AsyncDatabase</span>.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&quot;./notes.db&quot;</span>);\n  <span class=\"hljs-keyword\">await</span> db.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-string\">&quot;UPDATE users SET name = ? WHERE id = ?&quot;</span>, [username, id]);\n  <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">&quot;/&quot;</span>);\n}\n</code></pre><p>Done! Everything should work now.</p>\n<p>So let&#39;s talk a bit more in-depth about the caveats here</p>\n<ul>\n<li>You can&#39;t have client data from a client component fed into a server component. And it&#39;s going to annoy you. It&#39;s probably the most annoying thing to me about writing lots of RSCs.</li>\n<li>Rather, what you need to do is make more client components, and go back to the old way of using an API to make requests for data. So in that regard it&#39;s no worse than writing normal, old React.</li>\n<li>You can do this little hack I showed you, as long as you&#39;re not making the server component dependent on anything from client-side state.</li>\n<li>If you do want to have something like that, you&#39;ll need to gather the data from the client and trigger a full refresh of the page with the new client side data to use it (which sorta makes sense since they&#39;re server components.)</li>\n</ul>\n<p>This is it! You now understand all the various ways of looking at client and server components!</p>\n","markdown":"\nOkay, so we saw using a server component as a parent and passing data to a client component. What about going the other way? A client component rendering a server component? Well, it works, sort of, with a some caveats. A good thing to keep in mind is that, by necessity, server components render first and client components second. So we can't cross that barrier back the other way - going from the second/client components to the first/server components. But there's a little trick that we can do to somewhat get around this.\n\nMake a folder in app, call it `who-am-i`. Put a page.js file in there.\n\n```javascript\nimport ClientPage from \"./clientPage\";\nimport WhoAmI from \"./whoAmI\";\n\nexport default async function WhoAmIPage() {\n  return (\n    <ClientPage id={1}>\n      <WhoAmI />\n    </ClientPage>\n  );\n}\n```\n\nThis is the secret trick: we can just pre-render the server component first, and then pass the result to a client component to render it. Pretty cool, right? We'll talk more about it in a sec, but let's write whoAmI.js first.\n\n```javascript\nimport { AsyncDatabase } from \"promised-sqlite3\";\n\n// this page assumes that you are logged in as user 1\nasync function getWhoAmI() {\n  const db = await AsyncDatabase.open(\"./notes.db\");\n  return db.get(\"SELECT * FROM users WHERE id = ?\", [\"1\"]);\n}\n\nexport default async function WhoAmI() {\n  const user = await getWhoAmI();\n\n  return (\n    <div>\n      <h1>Who Am I?</h1>\n      <p>\n        You are {user.name} and your id is {user.id}\n      </p>\n    </div>\n  );\n}\n```\n\nAnd now clientPage.js\n\n```javascript\n\"use client\";\nimport updateUsername from \"./updateUsername\";\n\nexport default function ClientWhoAmIPage({ children, id }) {\n  return (\n    <div>\n      {children}\n      <form action={updateUsername}>\n        <h2>Enter new username</h2>\n        <input type=\"text\" name=\"username\" placeholder=\"username\" />\n        <input type=\"hidden\" name=\"id\" value={id} />\n        <button type=\"submit\">Submit</button>\n      </form>\n    </div>\n  );\n}\n```\n\nNow we have a client page rendering a server page! Let's go write that form action, updateUsername\n\n```javascript\n\"use server\";\nimport { AsyncDatabase } from \"promised-sqlite3\";\nimport { redirect } from \"next/navigation\";\n\nexport default async function updateUsername(formData) {\n  console.log(\"updateUsername called\", formData);\n\n  const username = formData.get(\"username\");\n  const id = formData.get(\"id\");\n\n  if (!username || !id) {\n    throw new Error(\"All fields are required\");\n  }\n\n  const db = await AsyncDatabase.open(\"./notes.db\");\n  await db.run(\"UPDATE users SET name = ? WHERE id = ?\", [username, id]);\n  redirect(\"/\");\n}\n```\n\nDone! Everything should work now.\n\nSo let's talk a bit more in-depth about the caveats here\n\n- You can't have client data from a client component fed into a server component. And it's going to annoy you. It's probably the most annoying thing to me about writing lots of RSCs.\n- Rather, what you need to do is make more client components, and go back to the old way of using an API to make requests for data. So in that regard it's no worse than writing normal, old React.\n- You can do this little hack I showed you, as long as you're not making the server component dependent on anything from client-side state.\n- If you do want to have something like that, you'll need to gather the data from the client and trigger a full refresh of the page with the new client side data to use it (which sorta makes sense since they're server components.)\n\nThis is it! You now understand all the various ways of looking at client and server components!\n","slug":"limitations-of-rscs","title":"Limitations of RSCs","section":"RSCs with Next.js","icon":"n","filePath":"/home/runner/work/intermediate-react-v6/intermediate-react-v6/lessons/04-rscs-with-nextjs/E-limitations-of-rscs.md","nextSlug":"/lessons/performance-optimizations/where-react-can-be-slow","prevSlug":"/lessons/rscs-with-nextjs/server-and-client-components-together"}},"__N_SSG":true}