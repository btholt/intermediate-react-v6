{"pageProps":{"post":{"attributes":{"description":"Learn how to effectively combine server and client components in React by implementing a polling system for real-time data updates, as explained by Brian Holt in Intermediate React v6 for Frontend Masters.","keywords":["React components","client-server","polling","real-time updates","Frontend Masters","Brian Holt"]},"html":"<p>One question you should probably have by this point is &quot;how do I mix server and client component?&quot; Super valid - we&#39;re obviously going to need both in order to ship complete apps. So how do we do that? Just by being a little judicious of how nest things and using React&#39;s innate ability to nest components.</p>\n<p>Let&#39;s say we have a secret teacher view that allows the teacher to see all the notes passed between everyone in their class. And we want that data to be consistently updated so a teacher can always see the latest notes. How would we do that? Let&#39;s do it with polling - we&#39;ll query the database for rows in the database and then we&#39;ll continually update it.</p>\n<p>Now, we could just make it totally a client component but we&#39;re going to make it load with complete data for the first time and then we&#39;ll start polling.</p>\n<p>So how do we do that? We&#39;ll have a server component loading the first page load&#39;s data, and then we&#39;ll have a child client component doing the polling and re-rendering. Best of both worlds!</p>\n<p>Make a folder called <code>teacher</code> in the app directory and put a page.js file in there with this in it:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">TeacherClientPage</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./clientPage&quot;</span>;\n<span class=\"hljs-keyword\">import</span> fetchNotes <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./fetchNotes&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">TeacherView</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> initialNotes = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchNotes</span>();\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TeacherClientPage</span> <span class=\"hljs-attr\">initialNotes</span>=<span class=\"hljs-string\">{initialNotes}</span> <span class=\"hljs-attr\">fetchNotes</span>=<span class=\"hljs-string\">{fetchNotes}</span> /&gt;</span></span>\n  );\n}\n</code></pre><p>This a server component that will load initial notes from a fetchNotes function and then feed it in as a prop. Let&#39;s go write that fetchNotes.js file.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-string\">&quot;use server&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AsyncDatabase</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;promised-sqlite3&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchNotes</span>(<span class=\"hljs-params\">since</span>) {\n  <span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">AsyncDatabase</span>.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">&quot;./notes.db&quot;</span>);\n  <span class=\"hljs-keyword\">let</span> rows;\n  <span class=\"hljs-keyword\">if</span> (since) {\n    rows = <span class=\"hljs-keyword\">await</span> db.<span class=\"hljs-title function_\">all</span>(\n      <span class=\"hljs-string\">&quot;SELECT n.id as id, n.note as note, f.name as from_user, t.name as to_user FROM notes n JOIN users f ON f.id = n.from_user JOIN users t ON t.id = n.to_user WHERE n.id &gt; ? LIMIT 50&quot;</span>,\n      [since]\n    );\n  } <span class=\"hljs-keyword\">else</span> {\n    rows = <span class=\"hljs-keyword\">await</span> db.<span class=\"hljs-title function_\">all</span>(\n      <span class=\"hljs-string\">&quot;SELECT n.id as id, n.note as note, f.name as from_user, t.name as to_user FROM notes n JOIN users f ON f.id = n.from_user JOIN users t ON t.id = n.to_user LIMIT 50&quot;</span>\n    );\n  }\n  <span class=\"hljs-keyword\">return</span> rows;\n}\n</code></pre><p>Another server function to fetch our latest update of rows. It&#39;ll only grab whatever is newer than what the client had. What&#39;s nice is we can share this function between the initial payload and the update function in the client. Let&#39;s go make clientPage.js then.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-string\">&quot;use client&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">TeacherClientPage</span>(<span class=\"hljs-params\">{ fetchNotes, initialNotes }</span>) {\n  <span class=\"hljs-keyword\">const</span> [notes, setNotes] = <span class=\"hljs-title function_\">useState</span>(initialNotes ? initialNotes : []);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> interval = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-title function_\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">let</span> since;\n      <span class=\"hljs-keyword\">if</span> (notes.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) {\n        since = notes[notes.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>]?.<span class=\"hljs-property\">id</span> ?? <span class=\"hljs-literal\">null</span>;\n      }\n      <span class=\"hljs-keyword\">const</span> newNotes = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetchNotes</span>(since);\n      <span class=\"hljs-title function_\">setNotes</span>([...notes, ...newNotes]);\n    }, <span class=\"hljs-number\">5000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">clearInterval</span>(interval);\n  }, []);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Teacher&#x27;s View<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n        {notes.map((note) =&gt; (\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{note.id}</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>\n                from: {note.from_user} | to: {note.to_user}\n              <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{note.note}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        ))}\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre><p>Now we have a client component that is using a server function to poll for changes, and its initial payload is seeded by a server component. Pretty cool, right? Best of both worlds.</p>\n","markdown":"\nOne question you should probably have by this point is \"how do I mix server and client component?\" Super valid - we're obviously going to need both in order to ship complete apps. So how do we do that? Just by being a little judicious of how nest things and using React's innate ability to nest components.\n\nLet's say we have a secret teacher view that allows the teacher to see all the notes passed between everyone in their class. And we want that data to be consistently updated so a teacher can always see the latest notes. How would we do that? Let's do it with polling - we'll query the database for rows in the database and then we'll continually update it.\n\nNow, we could just make it totally a client component but we're going to make it load with complete data for the first time and then we'll start polling.\n\nSo how do we do that? We'll have a server component loading the first page load's data, and then we'll have a child client component doing the polling and re-rendering. Best of both worlds!\n\nMake a folder called `teacher` in the app directory and put a page.js file in there with this in it:\n\n```javascript\nimport TeacherClientPage from \"./clientPage\";\nimport fetchNotes from \"./fetchNotes\";\n\nexport default async function TeacherView() {\n  const initialNotes = await fetchNotes();\n  return (\n    <TeacherClientPage initialNotes={initialNotes} fetchNotes={fetchNotes} />\n  );\n}\n```\n\nThis a server component that will load initial notes from a fetchNotes function and then feed it in as a prop. Let's go write that fetchNotes.js file.\n\n```javascript\n\"use server\";\nimport { AsyncDatabase } from \"promised-sqlite3\";\n\nexport default async function fetchNotes(since) {\n  const db = await AsyncDatabase.open(\"./notes.db\");\n  let rows;\n  if (since) {\n    rows = await db.all(\n      \"SELECT n.id as id, n.note as note, f.name as from_user, t.name as to_user FROM notes n JOIN users f ON f.id = n.from_user JOIN users t ON t.id = n.to_user WHERE n.id > ? LIMIT 50\",\n      [since]\n    );\n  } else {\n    rows = await db.all(\n      \"SELECT n.id as id, n.note as note, f.name as from_user, t.name as to_user FROM notes n JOIN users f ON f.id = n.from_user JOIN users t ON t.id = n.to_user LIMIT 50\"\n    );\n  }\n  return rows;\n}\n```\n\nAnother server function to fetch our latest update of rows. It'll only grab whatever is newer than what the client had. What's nice is we can share this function between the initial payload and the update function in the client. Let's go make clientPage.js then.\n\n```javascript\n\"use client\";\nimport { useState, useEffect } from \"react\";\n\nexport default function TeacherClientPage({ fetchNotes, initialNotes }) {\n  const [notes, setNotes] = useState(initialNotes ? initialNotes : []);\n\n  useEffect(() => {\n    const interval = setInterval(async () => {\n      let since;\n      if (notes.length > 0) {\n        since = notes[notes.length - 1]?.id ?? null;\n      }\n      const newNotes = await fetchNotes(since);\n      setNotes([...notes, ...newNotes]);\n    }, 5000);\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <div>\n      <h1>Teacher's View</h1>\n      <ul>\n        {notes.map((note) => (\n          <li key={note.id}>\n            <fieldset>\n              <h2>\n                from: {note.from_user} | to: {note.to_user}\n              </h2>\n              <p>{note.note}</p>\n            </fieldset>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\nNow we have a client component that is using a server function to poll for changes, and its initial payload is seeded by a server component. Pretty cool, right? Best of both worlds.\n","slug":"server-and-client-components-together","title":"Server and Client Components Together","section":"RSCs with Next.js","icon":"n","filePath":"/home/runner/work/intermediate-react-v6/intermediate-react-v6/lessons/04-rscs-with-nextjs/D-server-and-client-components-together.md","nextSlug":"/lessons/rscs-with-nextjs/limitations-of-rscs","prevSlug":"/lessons/rscs-with-nextjs/server-actions"}},"__N_SSG":true}