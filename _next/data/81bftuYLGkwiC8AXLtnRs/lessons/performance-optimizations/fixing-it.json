{"pageProps":{"post":{"attributes":{"description":"This guide explains how to optimize React component re-rendering using memoization techniques such as the memo function, useCallback, and useMemo, highlighting how these can prevent unnecessary re-renders by ensuring that a component only re-renders when its props or state variables change. Authored by Brian Holt for the Intermediate React v6 course, offered by Frontend Masters, this lesson is essential for web developers seeking to enhance React performance and manage state efficiently in their applications.","keywords":["React","memoization","useCallback","useMemo","Brian Holt","Frontend Masters","performance"]},"html":"<p>When does a component re-render? It re-renders when its parents have changed, always. But what if we could say &quot;only re-render when your props have changed&quot;? Frankly that&#39;s most components, but this is an opt-in pattern for React. Generally, like we said, renders are so cheap that introducing this &quot;memoization&quot; layer just makes it harder to debug. But in this case we need some help, so let&#39;s do it!</p>\n<p>In MarkdownPreview.jsx</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { memo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-comment\">// wrap function</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">memo</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MarkdownPreview</span>(<span class=\"hljs-params\">{ render, options }</span>) {\n  <span class=\"hljs-comment\">// code</span>\n});\n</code></pre><p>Now we&#39;ve told React &quot;only re-render this when the props haven&#39;t changed. But it&#39;s still re-rendering? Why?</p>\n<p>Well, answer me two questions</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> objectA = {};\n<span class=\"hljs-keyword\">const</span> objectB = {};\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(objectA === objectB); <span class=\"hljs-comment\">// is this true or false?</span>\n\n<span class=\"hljs-keyword\">const</span> functionA = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {};\n<span class=\"hljs-keyword\">const</span> functionB = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {};\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(functionA === functionB); <span class=\"hljs-comment\">// is this true or false?</span>\n</code></pre><p>If you run this, what will be the two logs? Go ahead and try it. Copy and paste it into your console.</p>\n<p>Did you get two <code>false</code>? It&#39;s because despite being equivalent in terms of what we&#39;ve instantiated them with, they are two separate entities. They&#39;re two different pointers, if you&#39;re familiar with C++ or other languages.</p>\n<p>So with our example, despite our functions and objects being constructed equivalently like in our little example here, they&#39;re considered <strong>not equal</strong> when React compares them.</p>\n<p>Well, damn, okay, how do we deal with that? useCallback and useMemo. Let&#39;s go do it in our app.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { useState, useCallback, useMemo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-comment\">// replace our options and render</span>\n<span class=\"hljs-keyword\">const</span> render = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">text</span>) =&gt;</span> marked.<span class=\"hljs-title function_\">parse</span>(text), []);\n<span class=\"hljs-keyword\">const</span> options = <span class=\"hljs-title function_\">useMemo</span>(<span class=\"hljs-function\">() =&gt;</span> ({ text, theme }), [text, theme]);\n</code></pre><ul>\n<li>There you go! Now it should be rendering and only re-rendering when needed! ðŸŽ‰</li>\n<li>Now it gives <em>the same</em> options and <em>the same</em> render each render so the <code>===</code> comparison will be true.</li>\n<li>The array following it works just like useEffect - it&#39;s essentially the cache key. If one of those things changes in the array, it invalidates the memo/callback and makes it render again.</li>\n</ul>\n","markdown":"\nWhen does a component re-render? It re-renders when its parents have changed, always. But what if we could say \"only re-render when your props have changed\"? Frankly that's most components, but this is an opt-in pattern for React. Generally, like we said, renders are so cheap that introducing this \"memoization\" layer just makes it harder to debug. But in this case we need some help, so let's do it!\n\nIn MarkdownPreview.jsx\n\n```javascript\n// at top\nimport { memo } from \"react\";\n\n// wrap function\nexport default memo(function MarkdownPreview({ render, options }) {\n  // code\n});\n```\n\nNow we've told React \"only re-render this when the props haven't changed. But it's still re-rendering? Why?\n\nWell, answer me two questions\n\n```javascript\nconst objectA = {};\nconst objectB = {};\n\nconsole.log(objectA === objectB); // is this true or false?\n\nconst functionA = function () {};\nconst functionB = function () {};\n\nconsole.log(functionA === functionB); // is this true or false?\n```\n\nIf you run this, what will be the two logs? Go ahead and try it. Copy and paste it into your console.\n\nDid you get two `false`? It's because despite being equivalent in terms of what we've instantiated them with, they are two separate entities. They're two different pointers, if you're familiar with C++ or other languages.\n\nSo with our example, despite our functions and objects being constructed equivalently like in our little example here, they're considered **not equal** when React compares them.\n\nWell, damn, okay, how do we deal with that? useCallback and useMemo. Let's go do it in our app.\n\n```javascript\n// at top\nimport { useState, useCallback, useMemo } from \"react\";\n\n// replace our options and render\nconst render = useCallback((text) => marked.parse(text), []);\nconst options = useMemo(() => ({ text, theme }), [text, theme]);\n```\n\n- There you go! Now it should be rendering and only re-rendering when needed! ðŸŽ‰\n- Now it gives _the same_ options and _the same_ render each render so the `===` comparison will be true.\n- The array following it works just like useEffect - it's essentially the cache key. If one of those things changes in the array, it invalidates the memo/callback and makes it render again.\n","slug":"fixing-it","title":"Fixing It","section":"Performance Optimizations","icon":"gauge-high","filePath":"/home/runner/work/intermediate-react-v6/intermediate-react-v6/lessons/05-performance-optimizations/C-fixing-it.md","nextSlug":"/lessons/performance-optimizations/other-perf-questions","prevSlug":"/lessons/performance-optimizations/the-project"}},"__N_SSG":true}